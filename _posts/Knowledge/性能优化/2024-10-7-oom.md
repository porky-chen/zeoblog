---
title: 内存泄漏和内存溢出(OOM)
author: zeo
categories: [知识点, 性能优化]
tags: [内存泄漏, 内存溢出, OOM]
render_with_liquid: false
---

在编程中，**内存泄漏**和**内存溢出（OOM：Out Of Memory）** 是两种常见的内存问题：

  

- **内存泄漏**：指程序在运行中不再使用的内存没有被及时释放，占用的内存空间无法被回收，从而导致内存浪费。

- **内存溢出（OOM）**：指程序需要分配的内存超过了系统或虚拟机的限制，导致程序崩溃。

  

这些问题通常出现在大型或长期运行的项目中，例如服务器后端、移动应用程序或 Web 前端页面。在现代语言如 JavaScript、Java、Python 等中，即便有垃圾回收机制，也可能因代码设计不当导致内存问题。

  

## **一、常见的内存泄漏原因**

  

### **1. 未清理的事件监听或回调函数**

  

未移除的事件监听器会使被监听的对象和回调函数继续占用内存，导致内存泄漏。例如，DOM 节点上的事件监听器若不移除，页面刷新或节点删除后依旧存在。

  

**如何避免**：

  

- 使用事件委托，减少事件监听的数量。

- 确保在不再需要监听时，通过 removeEventListener 移除事件。

- 在类组件中，通常可以在 componentWillUnmount（React）或 useEffect 的清理函数中移除监听器。

  

### **2. 全局变量或长生命周期对象**

  

全局变量由于生命周期长，在应用关闭之前都不会被释放，容易导致内存泄漏。同样地，在函数外部引用的对象或变量可能因被多处引用而无法被回收。

  

**如何避免**：

  

- 尽量避免使用全局变量；可以将数据封装在类或模块内，减少全局依赖。

- 使用 const 和 let 代替 var 定义变量，以避免无意间创建全局变量。

- 在作用域不再需要时，及时释放不再使用的对象或重置引用。

  

### **3. 闭包**

  

闭包会使被引用的变量无法被回收，尤其当闭包在某些回调函数中被反复创建时，容易导致内存泄漏。例如，循环中嵌套回调函数的闭包会创建多余的引用，内存占用不断增加。

  

**如何避免**：

  

- 合理使用闭包，尽量减少闭包中引用外部变量的次数。

- 在回调函数不再需要的场景中，将不再使用的闭包对象设置为 null。

- 在一些异步任务完成后，主动清理回调函数的引用。

  

### **4. DOM 引用未释放**

  

在 JavaScript 开发中，动态创建的 DOM 节点被移除时，若没有及时解除相关引用，将导致这些节点无法被垃圾回收。

  

**如何避免**：

  

- 动态创建的 DOM 元素不再使用时，及时将其引用设为 null。

- 使用合适的库（如 React、Vue）管理 DOM，避免手动管理，框架会自动处理节点回收。

  

### **5. 不断增长的数组或对象**

  

在一些场景中，如果持续往数组、对象中添加数据而不清理，内存会不断增大，可能导致内存溢出。例如，记录应用的所有操作日志，或每次请求都将数据加入数组而不清理。

  

**如何避免**：

  

- 定期清理不再使用的数组或对象元素，或仅保留最近需要的数据。

- 使用合适的数据结构，例如 WeakMap 或 WeakSet，可以在没有引用时自动回收。

- 控制数组或对象大小，对一些数据保留一定数量，删除不再需要的数据。

  

## **二、如何避免内存泄漏与 OOM**

  

### 1. **启用内存监测工具**

- 在开发阶段，使用内存调试工具（如 Chrome DevTools、VisualVM、Py-Spy、Memory Profiler 等）检查是否有无法回收的内存。

- 对比快照，查看是否有未被释放的变量、对象或节点。

### 2. **合理使用弱引用（Weak Reference）**

- WeakMap 和 WeakSet 提供了一种弱引用机制，当其中的对象不再被引用时会自动释放内存，非常适合用于缓存等不需要长期保留的对象。

- 对一些只用于临时操作的对象使用弱引用，确保在不再使用时自动释放。

### 3. **监控和定期清理缓存**

- 频繁使用缓存会导致 OOM，因此要对缓存设置限制，例如限制缓存数量或使用 LRU（Least Recently Used）策略定期清理旧数据。

- 定期清理不再需要的数据，避免不必要的内存占用。

### 4. **管理异步任务的生命周期**

- 异步任务（如 Promise、setTimeout、setInterval）在完成后未被清理也会导致内存泄漏。

- 定期清理不再需要的定时器或未完成的异步任务。可以在异步任务的生命周期结束后，手动释放引用。

### 5. **确保引用在适当时机被清理**

- 定期检查对象、变量的生命周期，确保不再使用的对象不再被引用。

- 尽量减少闭包、长时间存在的回调函数中对外部变量的引用。

  

## **三、总结**

  

内存泄漏和内存溢出可能会导致系统资源紧张、应用崩溃，甚至影响用户体验。为避免内存泄漏和 OOM，开发者需要：

  

- 充分理解语言的内存管理机制。

- 规范变量引用、事件监听器和异步任务的管理。

- 使用工具定期检测应用的内存情况，优化内存使用。

  

在代码设计时，尽量考虑内存管理问题，合理地处理对象引用，避免使用长期存留的全局变量，并使用自动回收机制，这样才能构建出更加稳定、高效的应用。